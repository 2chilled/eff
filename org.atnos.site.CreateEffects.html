<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Creating effects</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-1"></div>

<div class="col-md-1"></div>




<div class="col-md-10 col-sm-9 col-xs-9">
<h1>Creating effects</h1>
<div id="tipue_search_content"></div>

<h3 id="creation">Creation</h3>
<p>New effects can be added to the library pretty easily. Let’s create an Effect for a new “optional” type.</p>
<p>We need:</p>
<ul>
<li><p>a base type. We use a <code class="prettyprint">Maybe</code> data type with 2 cases <code class="prettyprint">Just</code> and <code class="prettyprint">Nothing</code></p></li>
<li><p>a method to send values of type <code class="prettyprint">A</code> into <code class="prettyprint">Eff[R, A]</code></p></li>
<li><p>an interpreter</p></li>
</ul>
<pre><code class="prettyprint">import cats._, implicits._
import org.atnos.eff._
import all._
import org.atnos.eff.interpret._

sealed trait Maybe[A]
case class Just[A](a: A) extends Maybe[A]
case class Nothing[A]() extends Maybe[A]

object MaybeEffect {
  type _maybe[R] = Maybe |= R

  def just[R :_maybe, A](a: A): Eff[R, A] =
    send[Maybe, R, A](Just(a))

  def nothing[R :_maybe, A]: Eff[R, A] =
    send[Maybe, R, A](Nothing())

  def runMaybe[R, U, A, B](effect: Eff[R, A])(implicit m: Member.Aux[Maybe, R, U]): Eff[U, Option[A]] =
    recurse(effect)(new Recurser[Maybe, U, A, Option[A]] {
      def onPure(a: A) = Some(a)

      def onEffect[X](m: Maybe[X]): X Either Eff[U, Option[A]] =
        m match {
          case Just(x)   =&gt; Left(x)
          case Nothing() =&gt; Right(Eff.pure(None))
        }

      def onApplicative[X, T[_]: Traverse](ms: T[Maybe[X]]): T[X] Either Maybe[T[X]] =
        Right(ms.sequence)
    })

  implicit val applicativeMaybe: Applicative[Maybe] = new Applicative[Maybe] {
    def pure[A](a: A): Maybe[A] = Just(a)

    def ap[A, B](ff: Maybe[A =&gt; B])(fa: Maybe[A]): Maybe[B] =
      (fa, ff) match {
        case (Just(a), Just(f)) =&gt; Just(f(a))
        case _                  =&gt; Nothing()
      }
  }
}
</code></pre>
<p>In the code above:</p>
<ul>
<li><p>the <code class="prettyprint">just</code> and <code class="prettyprint">nothing</code> methods use <code class="prettyprint">Eff.send</code> to “send” values into a larger sum of effects <code class="prettyprint">Eff[R, A]</code></p></li>
<li><p><code class="prettyprint">runMaybe</code> runs the <code class="prettyprint">Maybe</code> effect by using the <code class="prettyprint">interpret.recurse</code> and a <code class="prettyprint">Recurser</code> to translate <code class="prettyprint">Maybe</code> values into <code class="prettyprint">Option</code> values</p></li>
</ul>
<h3 id="compiler-limitation">Compiler limitation</h3>
<p>When you create an effect you can define a sealed trait and case classes to represent different possibilities for that effect. For example for interacting with a database you might create:</p>
<pre><code class="prettyprint">trait DatabaseEffect {

  case class Record(fields: List[String])

  sealed trait Db[A]
  case class Get[A](id: Int) extends Db[Record]
  case class Update[A](id: Int, record: Record) extends Db[Record]
}</code></pre>
<p>It is recommended to create the <code class="prettyprint">Db</code> types <strong>outside</strong> of the <code class="prettyprint">DatabaseEffect</code> trait. Indeed, during <code class="prettyprint">Member</code> implicit resolution, depending on how you import the <code class="prettyprint">Db</code> effect type (if it is inherited from an object or not) you could experience compiler crashes :-(.</p>
<h3 id="interpreter">Interpreter</h3>
<p>Interpreting a given effect generally means knowing what to do with a value of type <code class="prettyprint">M[X]</code> where <code class="prettyprint">M</code> is the effect. If the interpreter can “execute” the effect: produce logs (<code class="prettyprint">Writer</code>), execute asynchronously (<code class="prettyprint">Future</code>), check the value (<code class="prettyprint">Either</code>),… then extract a value <code class="prettyprint">X</code>, then we can call a continuation to get the next effect and interpret it as well.</p>
<p>The <code class="prettyprint">org.atnos.eff.interpret</code> object offers several support traits and functions to write interpreters. In this example we use a <code class="prettyprint">Recurser</code> which will be used to “extract” a value <code class="prettyprint">X</code> from <code class="prettyprint">Maybe[X]</code> or just give up with <code class="prettyprint">Eff.pure(None)</code></p>
<p>The <code class="prettyprint">runMaybe</code> method needs an implicit <code class="prettyprint">Member.Aux[Maybe, R, U]</code>. This must be read in the following way:</p>
<ul>
<li><code class="prettyprint">Maybe</code> must be member of the effect stack <code class="prettyprint">R</code> and its removal from <code class="prettyprint">R</code> should be the effect stack <code class="prettyprint">U</code></li>
</ul>
<p><br/></p>
<p>Then we can use this effect in a computation:</p>
<pre><code class="prettyprint">val action: Eff[Fx.fx1[Maybe], Int] =
  for {
    a &lt;- just(2)
    b &lt;- just(3)
  } yield a + b

run(runMaybe(action))</code></pre>
<p><code class="prettyprint">&gt; Some(5)</code></p>
<hr />
</div>

</div>

</body>
</html>
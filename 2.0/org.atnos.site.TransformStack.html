<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Transforming stacks</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-1"></div>

<div class="col-md-1"></div>




<div class="col-md-10">
<h1>Transforming stacks</h1>
<div id="tipue_search_content"></div>

<h3 id="what-is-an-effect-stack">What is an “effect stack”?</h3>
<p>There is an abuse of language here. The name “stack” comes from “monad stack” used when talking about monad transformers. With <code class="prettyprint">Eff</code> though, effects are modelled differently, as a tree of effects.</p>
<p>For example the type level representation of four effects <code class="prettyprint">T1, T2, T3, T4</code> is represented as:</p>
<pre><code class="prettyprint">Fx.fx4[T1, T2, T3, T4]

// or

FxAppend[
  Fx1[T1],
  Fx3[T2, T3, T4]
]</code></pre>
<p>So every-time we manipulate effects at the type level we modify a tree of effects. For example, interpreting the effect <code class="prettyprint">T3</code> would leave us with the tree:</p>
<pre><code class="prettyprint">FxAppend[
  Fx1[T1],
  Fx2[T2, T4]
]</code></pre>
<p>This code should prove it:</p>
<pre><code class="prettyprint">// for now the following implicit summoning crashes the compiler
  //val member_ : Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]] =
  //  implicitly[Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]]]</code></pre>
<p>Unfortunately the compiler has some difficulties with it, so you can either get the member value by using the implicit definitions “manually” or you can just summon the member instance without the <code class="prettyprint">Aux</code> part:</p>
<pre><code class="prettyprint">// so you need to explicitly define the implicit
val member_ : Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]] =
  Member.MemberAppendR(Member.Member3M)

// but this works
val member: Member[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]]] =
  implicitly[Member[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]]]]</code></pre>
<p>More importantly the compiler is still able to track the right types resulting of the interpretation of a given effect so the following compiles ok:</p>
<pre><code class="prettyprint">def runT3[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T3, R, U]): Eff[U, A] = ???
def runT2[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T2, R, U]): Eff[U, A] = ???
def runT1[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T1, R, U]): Eff[U, A] = ???
def runT4[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T4, R, U]): Eff[U, A] = ???

type S = FxAppend[Fx1[T1], Fx3[T2, T3, T4]]

runT1(runT4(runT2(runT3(Eff.send[T3, S, Int](???)))))</code></pre>
<h3 id="transform-an-effect-to-another">Transform an effect to another</h3>
<h4 id="change-the-effect">Change the effect</h4>
<p>A typical use case for this is to transform a stack having a <code class="prettyprint">Reader[S, ?]</code> effect to a stack having a <code class="prettyprint">Reader[B, ?]</code> effect where <code class="prettyprint">S</code> is “contained” in <code class="prettyprint">B</code> (meaning that there is a mapping from <code class="prettyprint">B</code>, “big”, to <code class="prettyprint">S</code>, “small”). Here is an example:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._
import org.atnos.eff.syntax.all._
import cats.data._

case class Conf(host: String, port: Int)

type ReaderPort[A] = Reader[Int, A]
type ReaderHost[A] = Reader[String, A]
type ReaderConf[A] = Reader[Conf, A]

type S1 = Fx.fx2[ReaderHost, Option]
type S2 = Fx.fx2[ReaderPort, Option]
type SS = Fx.fx2[ReaderConf, Option]

val readHost: Eff[S1, String] = for {
  c &lt;- ask[S1, String]
  h &lt;- OptionEffect.some[S1, String](&quot;hello&quot;)
} yield h

val readPort: Eff[S2, String] = for {
  c &lt;- ask[S2, Int]
  h &lt;- OptionEffect.some[S2, String](&quot;world&quot;)
} yield h

val fromHost = new (ReaderHost ~&gt; ReaderConf) {
  def apply[X](r: ReaderHost[X]) = Reader((c: Conf) =&gt; r.run(c.host))
}

val fromPort = new (ReaderPort ~&gt; ReaderConf) {
  def apply[X](r: ReaderPort[X]) = Reader((c: Conf) =&gt; r.run(c.port))
}

val action: Eff[SS, String] = for {
  s1 &lt;- readHost.transform(fromHost)
  s2 &lt;- readPort.transform(fromPort)
} yield s1 + &quot; &quot; + s2

action.runReader(Conf(&quot;www.me.com&quot;, 8080)).runOption.run</code></pre>
<p><code class="prettyprint">&gt; Some(hello world)</code></p>
<p>There are also specialized versions of <code class="prettyprint">transform</code> for <code class="prettyprint">Reader</code> and <code class="prettyprint">State</code>:</p>
<ul>
<li><code class="prettyprint">ReaderEffect.localReader</code> takes a “getter” <code class="prettyprint">B =&gt; A</code> to transform a stack with a <code class="prettyprint">Reader[A, ?]</code> into a stack with a <code class="prettyprint">Reader[B, ?]</code></li>
<li><code class="prettyprint">StateEffect.lensState</code> takes a “getter” <code class="prettyprint">S =&gt; T</code> and a “setter” <code class="prettyprint">(S, T) =&gt; S</code> to to transform a stack with a <code class="prettyprint">State[T, ?]</code> into a stack with a <code class="prettyprint">State[S, ?]</code></li>
</ul>
<h3 id="effects-translation">Effects translation</h3>
<p>A common thing to do is to translate “high-level” effects (a webservice DSL for example) into low-level ones (<code class="prettyprint">Future</code>, <code class="prettyprint">Eval</code>, <code class="prettyprint">Xor</code>, etc…).</p>
<p>For example you might have this stack: <code class="prettyprint">type S = Fx.fx3[Authenticated, Future, ThrowableXor]</code></p>
<p>And you want to write an interpreter which will translate authentication actions into <code class="prettyprint">Future</code> and <code class="prettyprint">Xor</code>:</p>
<pre><code class="prettyprint">import org.atnos.eff.eff._
  import org.atnos.eff.syntax.eff._
  import org.atnos.eff.future._
  import org.atnos.eff.interpret._
  import scala.concurrent.Future

  // list of access rights for a valid token
  case class AccessRights(rights: List[String])

  // authentication error
  case class AuthError(message: String)

  // DSL for authenticating users
  sealed trait Authenticated[A]
  case class Authenticate(token: String) extends Authenticated[AccessRights]

  type AuthErroXor[A] = AuthError Xor A
  type _error[R] = AuthErroXor |= R

  /**
   * The order of implicit parameters is really important for type inference!
   * see below
   */
  def runAuth[R, U, A](e: Eff[R, A])(implicit
    authenticated: Member.Aux[Authenticated, R, U],
     future:       _future[U],
     xor:          _error[U]): Eff[U, A] =

     translate(e)(new Translate[Authenticated, U] {
       def apply[X](ax: Authenticated[X]): Eff[U, X] =
         ax match {
           case Authenticate(token) =&gt;
             // send the future effect in the stack U
             send(authenticate(token)).
             // send the Xor value in the stack U
             collapse
         }
      })

// call to a service to authenticate tokens
def authenticate(token: String): Future[AuthError Xor AccessRights] = ???

type S = Fx.fx3[Authenticated, AuthError Xor ?, Future]
def auth: Eff[S, Int] = ???

runAuth(auth)</code></pre>
<p>The call to <code class="prettyprint">send</code> above needs to send a <code class="prettyprint">Future</code> value in the stack <code class="prettyprint">U</code>. This is possible because <code class="prettyprint">Future</code> is an effect in <code class="prettyprint">U</code> as evidenced by <code class="prettyprint">future</code>.</p>
<p>Furthermore, <code class="prettyprint">authenticate</code> returns an <code class="prettyprint">AuthError Xor ?</code> value. We can “collapse” it into <code class="prettyprint">U</code> because <code class="prettyprint">AuthError Xor ?</code> is an effect of <code class="prettyprint">U</code> as evidenced by <code class="prettyprint">xor</code>.</p>
<p>You might wonder why we don’t use a more direct type signature like:</p>
<pre><code class="prettyprint">def runAuth2[R, U :_future :_error, A](e: Eff[R, A])(implicit authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A]</code></pre>
<p>The reason is that scalac desugars this to:</p>
<pre><code class="prettyprint">def runAuth2[R, U, A](e: Eff[R, A])(
  implicit future:        _future[U],
           xor:           _error[U],
           authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A] =
  ```

And then `authenticated` is last in the list of implicits parameters and can not be used to guide type inference.

### Interpret an effect &quot;locally&quot;

Let&#39;s say you have a method to run database queries

</code></pre>
<p>import org.atnos.eff.all._</p>
<p>trait Db[A] type _writerString[R] = Writer[String, ?] |= R</p>
<p>def runDb<a href="queries:%20Eff%5BR,%20A%5D">R, U, A</a>( implicit db: Member.Aux[Db, R, U], eval: _eval[U], writer: _writerString[U]): Eff[U, A] = ???</p>
<pre><code class="prettyprint">

The database queries (the `Db` effect) are being executed by the `runDb` method inside the `Eval` effect, and they use
 a `WriterString` effect to log what is being executed.

However you know that some clients of your component don&#39;t care about the logs and they don&#39;t want to have the `WriterString` effect.
 that they consider an implementation detail.

So you&#39;d like to provide this additional method:

</code></pre>
<p>def executeOnDb<a href="queries:%20Eff%5BR,%20A%5D">R, U, A</a>( implicit db: Member.Aux[Db, R, U], eval: _eval[U]): Eff[U, A] = ???</p>
<pre><code class="prettyprint">

How can you implement `executeOnDb` with `runDb`?

</code></pre>
<p>import org.atnos.eff.all.<em>, syntax.all.</em></p>
<p>def executeOnDb<a href="queries:%20Eff%5BR,%20A%5D">R, U, A</a>( implicit db: Member.Aux[Db, R, U], eval: _eval[U]): Eff[U, A] = {</p>
<p>type S = Fx.prepend[WriterString, R] runDb(queries.into[S]).runWriterNoLog[String]</p>
<p>}</p>
<pre><code class="prettyprint">

You create a &quot;local&quot; stack containing the `WriterString` effect using the `prepend` method. You now run the `Db` effect and
discard the logs to finally return only `Eff[U, A]`.

### Merge stacks

We can create effects for a given effect stack, for example to interact with a [Hadoop](https://hadoop.apache.org) cluster.
We can also define another stack, for storing and retrieving data on [S3](https://aws.amazon.com/s3).
  
</code></pre>
<p>import org.atnos.eff.<em>, all.</em> import cats.data._ import cats.Eval</p>
<p>object HadoopStack {</p>
<p>case class HadoopConf(mappers: Int)</p>
<p>type HadoopReader[A] = Reader[HadoopConf, A] type WriterString[A] = Writer[String, A] type Hadoop = Fx.fx3[HadoopReader, WriterString, Eval]</p>
<p>def readFile(path: String): Eff[Hadoop, String] = for { c &lt;- ask[Hadoop, HadoopConf] _ &lt;- tell[Hadoop, String](“Reading from”+path) } yield c.mappers.toString</p>
<p>def runHadoopReader<a href="conf:%20HadoopConf">R, U, A</a>(e: Eff[R, A])(implicit r: Member.Aux[HadoopReader, R, U]): Eff[U, A] = ReaderEffect.runReader(conf)(e)</p>
<p>}</p>
<p>object S3Stack {</p>
<p>case class S3Conf(bucket: String)</p>
<p>type S3Reader[A] = Reader[S3Conf, A] type WriterString[A] = Writer[String, A]</p>
<p>type S3 = Fx.fx3[S3Reader, WriterString, Eval]</p>
<p>def writeFile(key: String, content: String): Eff[S3, Unit] = for { c &lt;- ask[S3, S3Conf] _ &lt;- tell[S3, String](“Writing to bucket”+c.bucket+“:”+content) } yield ()</p>
<p>def runS3Reader<a href="conf:%20S3Conf">R, U, A</a>(e: Eff[R, A])(implicit r: Member.Aux[S3Reader, R, U]): Eff[U, A] = ReaderEffect.runReader(conf)(e) }</p>
<pre><code class="prettyprint">

So what happens when you want to both use S3 and Hadoop? As you can see from the definition above those 2 stacks share
some common effects, so the resulting stack we want to work with is:
</code></pre>
<p>import org.atnos.eff.<em> import cats.Eval import HadoopStack.</em> import S3Stack.{WriterString=&gt;<em>,</em>}</p>
<p>type HadoopS3 = Fx.fx4[S3Reader, HadoopReader, WriterString, Eval]</p>
<pre><code class="prettyprint">

Then we can use the `into` method to inject effects from each stack into this common stack:
</code></pre>
<p>// this imports the <code class="prettyprint">into</code> and runXXX syntax import org.atnos.eff.syntax.all._</p>
<p>val action = for { // read a file from hadoop s &lt;- readFile(“/tmp/data”).into[HadoopS3]</p>
<p>// write a file on S3 _ &lt;- writeFile(“key”, s) .into[HadoopS3] } yield ()</p>
<p>// and we can run the composite action action.runReader(S3Conf(“bucket”)).runReader(HadoopConf(10)).runWriter.runEval.run ```</p>
<p><code class="prettyprint">&gt; ((),List(Reading from /tmp/data, Writing to bucket bucket: 10))</code></p>
<p>You can find a fully working example of this approach in <code class="prettyprint">src/test/org/atnos/example/StacksSpec</code>.</p>
</div>

</div>

</body>
</html>
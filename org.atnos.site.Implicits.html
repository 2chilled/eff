<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Implicits</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-1"></div>

<div class="col-md-1"></div>




<div class="col-md-10">
<h1>Implicits</h1>
<div id="tipue_search_content"></div>

<p>Type inference with the Eff monad can be a bit tricky to get right if we want to avoid type annotations. Here are some tips to help you.</p>
<h3 id="running-effects-with-several-type-parameters">Running effects with several type parameters</h3>
<p>Some effects use 2 type variables, like <code class="prettyprint">Reader</code> or <code class="prettyprint">Writer</code>. If you want to use those effects in an effect stack you need to add a compiler plugin to your build:</p>
<pre><code class="prettyprint">addCompilerPlugin(&quot;com.milessabin&quot; % &quot;si2712fix-plugin_2.11.8&quot; % &quot;1.1.0&quot;)</code></pre>
<h3 id="use-context-bounds-and-type-aliases">Use context bounds and type aliases</h3>
<p>When creating effects you can always “require” a stack containing the right effects with the <code class="prettyprint">Member</code> typeclass:</p>
<pre><code class="prettyprint">import org.atnos.eff._
import org.atnos.eff.all._

type StateInt[A] = State[Int, A]
type WriterString[A] = Writer[String, A]

// for creating state effects
def putAndTell[R](i: Int)(implicit s: StateInt &lt;= R, w: WriterString &lt;= R): Eff[R, Int] =
  for {
    // no type annotations needed!
    _ &lt;- put(i)
    _ &lt;- tell(&quot;stored &quot; + i)
  } yield i</code></pre>
<p>You can even use context bounds to make the declaration of <code class="prettyprint">putAndTell</code> more concise:</p>
<pre><code class="prettyprint">import org.atnos.eff.all._

type _stateInt[R] = State[Int, ?] |= R
type _writerString[R] = Writer[String, ?] |= R

def putAndTell[R :_stateInt :_writerString](i: Int): Eff[R, Int] =
  for {
    _ &lt;- put(i)
    _ &lt;- tell(&quot;stored &quot; + i)
  } yield i</code></pre>
<h3 id="creating-effects-for-your-own-stack">Creating effects for your own stack</h3>
<p>When you create your own effect stack you can give a little help to the compiler by adding <code class="prettyprint">Member.Aux</code> implicits for each effect in the stack:</p>
<pre><code class="prettyprint">import cats.data._
import org.atnos.eff._
import org.atnos.eff.all._

object S {
  type StateInt[A] = State[Int, A]
  type WriterString[A] = Writer[String, A]

  type S = StateInt |: WriterString |: NoEffect

  // for the first effect of the stack
  implicit val StateIntMember: Member.Aux[StateInt, S, WriterString |: NoEffect] =
    Member.first

  // for the next effect
  implicit val WriterStringMember: Member.Aux[WriterString, S, StateInt |: NoEffect] =
    Member.successor
}

import S._

def putAndTell(i: Int): Eff[S, Int] =
  for {
    // no annotations!
    _ &lt;- put(i)
    _ &lt;- tell(&quot;stored &quot;+i)
  } yield i</code></pre>
<p>The implicit <code class="prettyprint">StateIntMember</code> declares that:</p>
<ul>
<li><p><code class="prettyprint">StateInt</code> is a member of <code class="prettyprint">S</code></p></li>
<li><p>if you remove <code class="prettyprint">StateInt</code> from <code class="prettyprint">S</code>, you are left with the <code class="prettyprint">WriterString |: NoEffect</code> stack</p></li>
</ul>
<h3 id="effect-deduction">Effect deduction</h3>
<p>A common thing to do is to translate “high-level” effects (a webservice DSL for example) into low-level ones (<code class="prettyprint">Future</code>, <code class="prettyprint">Eval</code>, <code class="prettyprint">Xor</code>, etc…).</p>
<p>For example you might have this stack:</p>
<pre><code class="prettyprint">type S = Authenticated |: Future |: (Throwable Xor ?) |: NoEffect</code></pre>
<p>And you want to write an interpreter which will translate authentication actions into <code class="prettyprint">Future</code> and <code class="prettyprint">Xor</code>:</p>
<pre><code class="prettyprint">import org.atnos.eff.eff._
import org.atnos.eff.syntax.eff._
import org.atnos.eff.future._
import org.atnos.eff.interpret._
import scala.concurrent.Future

// list of access rights for a valid token
case class AccessRights(rights: List[String])

// authentication error
case class AuthError(message: String)

// DSL for authenticating users
sealed trait Authenticated[A]
case class Authenticate(token: String) extends Authenticated[AccessRights]

type _error[R] = (AuthError Xor ?) |= R


def runAuth[R :_future :_error, U, A](e: Eff[R, A])(implicit m: Member.Aux[Authenticated, R, U]): Eff[U, A] =
  translate(e) { new Translate[Authenticated, U] {
    def apply[X](ax: Authenticated[X]): Eff[U, X] =
      ax match {
        case Authenticate(token) =&gt;
          // send the future effect in the stack U
          send(authenticate(token))(m.out[Future]).
          // send the Xor value in the stack U
          collapse(m.out[AuthError Xor ?])
      }
  }}

// call to a service to authenticate tokens
def authenticate(token: String): Future[AuthError Xor AccessRights] = ???</code></pre>
<p>The call to <code class="prettyprint">send</code> above needs to send a <code class="prettyprint">Future</code> value in the stack <code class="prettyprint">U</code>. But the type signature of <code class="prettyprint">runAuth</code> only indicates that:</p>
<ul>
<li><code class="prettyprint">Future</code> is an effect in <code class="prettyprint">R</code></li>
<li><code class="prettyprint">Authenticated</code> is an effect in <code class="prettyprint">R</code> and removing it from <code class="prettyprint">R</code> leaves us with <code class="prettyprint">U</code></li>
</ul>
<p>We should be able to deduce from those 2 facts that <code class="prettyprint">Future</code> is also an effect of <code class="prettyprint">U</code> but we need to show a proof of that. This is what <code class="prettyprint">m.out[Future]</code> does. It builds a <code class="prettyprint">MemberIn[Future, U]</code> instance which can then be used to inject a <code class="prettyprint">Future</code> into <code class="prettyprint">U</code>.</p>
<p>You might wonder why we don’t use a more direct type signature like:</p>
<pre><code class="prettyprint">def runAuth2[R, U :_future :_error, A](e: Eff[R, A])(implicit m: Member.Aux[Authenticated, R, U]): Eff[U, A] =</code></pre>
<p>The reason is that Scala has some difficulty to infer the type parameters when calling <code class="prettyprint">runAuth2</code> and they have to be explicitly provided. The first declaration works fine with type inference.</p>
</div>

</div>

</body>
</html>